-- MIGRATE (complete)

DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE messages
        ADD COLUMN IF NOT EXISTS var_fields jsonb,
        ADD COLUMN IF NOT EXISTS images jsonb,
        ADD COLUMN IF NOT EXISTS access text,
        ADD COLUMN IF NOT EXISTS is_offer boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS is_want boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS is_service boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS is_stuff boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS subject text,
        ADD COLUMN IF NOT EXISTS message text,
        ADD COLUMN IF NOT EXISTS category_id int,
        ADD COLUMN IF NOT EXISTS user_id int,
        DROP COLUMN IF EXISTS noannounce,
        DROP COLUMN IF EXISTS uuid,
        DROP COLUMN IF EXISTS exp_admin_warn
        ;
   ALTER TABLE users
        ALTER COLUMN comments TYPE text,
        ALTER COLUMN admincomment TYPE text,
        ALTER COLUMN password TYPE text,
        ADD COLUMN IF NOT EXISTS role text,
        ADD COLUMN IF NOT EXISTS code text,
        ADD COLUMN IF NOT EXISTS var_fields jsonb,
        ADD COLUMN IF NOT EXISTS remote_schema text,
        ADD COLUMN IF NOT EXISTS is_active boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS is_pre_active boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS is_leaving boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS has_registered_online boolean not null default 'f',
        ADD COLUMN IF NOT EXISTS image text,
        ADD COLUMN IF NOT EXISTS fullname_access text,
        DROP COLUMN IF EXISTS privkey,
        DROP COLUMN IF EXISTS pubkey,
        DROP COLUMN IF EXISTS ostatus_id,
        DROP COLUMN IF EXISTS locked,
        DROP COLUMN IF EXISTS lang,
        DROP COLUMN IF EXISTS pwchange,
        DROP COLUMN IF EXISTS id_region,
        DROP COLUMN IF EXISTS login,
        DROP COLUMN IF EXISTS pictureid
        ;
   ALTER TABLE contact
        ADD COLUMN IF NOT EXISTS access text
        ;
   ALTER TABLE type_contact
        DROP COLUMN IF EXISTS protect
        ;
   ALTER TABLE news
        ADD COLUMN IF NOT EXISTS access text,
        ADD COLUMN IF NOT EXISTS subject text,
        ADD COLUMN IF NOT EXISTS message text
        ;
   ALTER TABLE transactions
        DROP COLUMN IF EXISTS date,
        ADD COLUMN IF NOT EXISTS var_fields jsonb,
        ADD COLUMN IF NOT EXISTS from_account_id int,
        ADD COLUMN IF NOT EXISTS from_remote_schema text,
        ADD COLUMN IF NOT EXISTS from_remote_account_id int,
        ADD COLUMN IF NOT EXISTS from_remote_name text,
        ADD COLUMN IF NOT EXISTS remote_id int,
        ADD COLUMN IF NOT EXISTS to_account_id int,
        ADD COLUMN IF NOT EXISTS to_remote_schema text,
        ADD COLUMN IF NOT EXISTS to_remote_account_id int,
        ADD COLUMN IF NOT EXISTS to_remote_name text,
        ADD COLUMN IF NOT EXISTS is_intersystem boolean
        ;
   CREATE TABLE IF NOT EXISTS forum_topics (
        id serial primary key not null,
        subject text not null,
        old_id text,
          cdate timestamp without time zone default timezone('utc'::text, now()),
          mdate timestamp without time zone default timezone('utc'::text, now()),
        access text not null
   );
     CREATE TABLE IF NOT EXISTS forum_posts (
          id serial primary key not null,
          user_id int,
          content text not null,
          old_id text,
          old_parent_id text,
          parent_id int,
          edit_count int,
          cdate timestamp without time zone default timezone('utc'::text, now()),
          mdate timestamp without time zone default timezone('utc'::text, now()),
     );

   CREATE TABLE IF NOT EXISTS doc_maps (
        id serial primary key not null,
        name text not null,
        old_id text,
          cdate timestamp without time zone default timezone('utc'::text, now()),
          mdate timestamp without time zone default timezone('utc'::text, now())
   );
     CREATE TABLE IF NOT EXISTS docs (
          id serial primary key not null,
          user_id int,
          filename text not null,
          old_id text,
          old_map_id text,
          map_id int,
          cdate timestamp without time zone default timezone('utc'::text, now()),
          mdate timestamp without time zone default timezone('utc'::text, now()),
          edit_count int
     );

   CREATE TABLE IF NOT EXISTS static_contents (
        id text primary key not null,
        content text
   );

    DROP TABLE IF EXISTS city_distance CASCADE;
    DROP TABLE IF EXISTS cron CASCADE;
    DROP TABLE IF EXISTS interletsq CASCADE;
    DROP TABLE IF EXISTS lists CASCADE;
    DROP TABLE IF EXISTS listsubscriptions CASCADE;
    DROP TABLE IF EXISTS openid CASCADE;
    DROP TABLE IF EXISTS ostatus_queue CASCADE;
    DROP TABLE IF EXISTS parameters;
    DROP TABLE IF EXISTS config;
END LOOP;

END
$do$

-- REVERSE

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE messages
        DROP COLUMN IF EXISTS var_fields,
        DROP COLUMN IF EXISTS images,
        DROP COLUMN IF EXISTS subject,
        DROP COLUMN IF EXISTS message,
        DROP COLUMN IF EXISTS is_stuff,
        DROP COLUMN IF EXISTS is_service,
        DROP COLUMN IF EXISTS is_offer,
        DROP COLUMN IF EXISTS is_want,
        DROP COLUMN IF EXISTS category_id,
        DROP COLUMN IF EXISTS user_id,
        DROP COLUMN IF EXISTS access
        ;
   ALTER TABLE users
        DROP COLUMN IF EXISTS var_fields,
        DROP COLUMN IF EXISTS fullname_access,
        DROP COLUMN IF EXISTS remote_schema,
        DROP COLUMN IF EXISTS role,
        DROP COLUMN IF EXISTS code,
        DROP COLUMN IF EXISTS is_active,
        DROP COLUMN IF EXISTS is_pre_active,
        DROP COLUMN IF EXISTS is_leaving,
        DROP COLUMN IF EXISTS has_registered_online,
        DROP COLUMN IF EXISTS image,
        DROP COLUMN IF EXISTS fullname_access
        ;
   ALTER TABLE contact
        DROP COLUMN IF EXISTS access
        ;
   ALTER TABLE news
        DROP COLUMN IF EXISTS access,
        DROP COLUMN IF EXISTS subject,
        DROP COLUMN IF EXISTS message
        ;
   ALTER TABLE transactions
        DROP COLUMN IF EXISTS var_fields,
        DROP COLUMN IF EXISTS to_schema,
        DROP COLUMN IF EXISTS to_remote_id,
        DROP COLUMN IF EXISTS from_schema,
        DROP COLUMN IF EXISTS from_remote_id
        ;
END LOOP;

END
$do$

-- STEP 1 remove obsolete tables and columns

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE messages
        DROP COLUMN IF EXISTS noannounce,
        DROP COLUMN IF EXISTS uuid,
        DROP COLUMN IF EXISTS exp_admin_warn
        ;
   ALTER TABLE type_contact
        DROP COLUMN IF EXISTS protect
        ;
   ALTER TABLE transactions
        DROP COLUMN IF EXISTS date
        ;
   ALTER TABLE users
      ALTER COLUMN password TYPE text,
      ALTER COLUMN name TYPE text,
      ALTER COLUMN postcode TYPE text,
      ALTER COLUMN letscode TYPE text,
      ALTER COLUMN accountrole TYPE text,
      ALTER COLUMN comments TYPE text,
      ALTER COLUMN admincomment TYPE text,
      ALTER COLUMN fullname TYPE text,
      ALTER COLUMN hobbies DROP NOT NULL,
      ALTER COLUMN hobbies DROP DEFAULT,
      ALTER COLUMN creator DROP NOT NULL,
      ALTER COLUMN creator DROP DEFAULT,
      ALTER COLUMN letscode DROP NOT NULL,
      ALTER COLUMN letscode DROP DEFAULT,
      ALTER COLUMN postcode DROP NOT NULL,
      ALTER COLUMN postcode DROP DEFAULT,
      ALTER COLUMN minlimit DROP NOT NULL,
      ALTER COLUMN minlimit DROP DEFAULT,
      ALTER COLUMN maxlimit DROP NOT NULL,
      ALTER COLUMN maxlimit DROP DEFAULT;
   UPDATE users SET minlimit = NULL where minlimit = -999999999;
   UPDATE users SET maxlimit = NULL where maxlimit = 999999999;


    DROP TABLE IF EXISTS city_distance CASCADE;
    DROP TABLE IF EXISTS cron CASCADE;
    DROP TABLE IF EXISTS interletsq CASCADE;
    DROP TABLE IF EXISTS lists CASCADE;
    DROP TABLE IF EXISTS listsubscriptions CASCADE;
    DROP TABLE IF EXISTS openid CASCADE;
    DROP TABLE IF EXISTS ostatus_queue CASCADE;
    DROP TABLE IF EXISTS parameters;
    DROP TABLE IF EXISTS config;
END LOOP;
END
$do$

-- TEMP TABLE FILL

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   INSERT INTO xdb.temp_inter_trans(schema, id, from_id, to_id, transid)
     SELECT f_schema, id, id_from, id_to, transid
     FROM transactions
     WHERE (transid <> '' and transid is not null)
          and (real_from <> ''
          or real_from is not null
          or real_to <> ''
          or real_to is not null);
END LOOP;
END
$do$

--

--- TEMP TABLE

CREATE TABLE IF NOT EXISTS xdb.temp_inter_trans (
id int,
schema text,
from_id int,
to_id int,
transid text);



---------

UPDATE messages m
SET image_files = (
   SELECT json_agg(elem)::jsonb
   FROM  (
      SELECT p."PictureFile" as elem
      FROM msgpictures p
     WHERE p.msgid = m.id
     ORDER BY p.id ASC
      ) sub
   );


------------ create image_files -----------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE messages ADD COLUMN IF NOT EXISTS image_files jsonb NOT NULL DEFAULT '{}'::jsonb;
END LOOP;
END
$do$

------------ load image_files values -----------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
UPDATE messages m
SET image_files = (
   SELECT json_agg(elem)::jsonb
   FROM  (
      SELECT p."PictureFile" as elem
      FROM msgpictures p
     WHERE p.msgid = m.id
     ORDER BY p.id ASC
      ) sub
   );
END LOOP;
END
$do$

----------------------------------------


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE users ADD COLUMN IF NOT EXISTS image_file text;
END LOOP;
END
$do$

--------------------


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   select id, f_schema, letscode from users ou where (select count(*) from users inn where lower(inn.letscode) = lower(ou.letscode)) > 1;
END LOOP;
END
$do$

--------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     create table if not exists config  (
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          id text primary key,
          data jsonb not null default '{}'::jsonb);
     create table if not exists forum_topics (
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          id serial primary key,
          access text not null,
          old_id text,
          subject text not null,
          user_id int not null);
     create table if not exists forum_posts (
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          id serial primary key,
          parent_id int,
          old_parent_id text,
          content text not null,
          edit_count int not null default 0,
          user_id int not null);
     create table if not exists doc_maps (
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          id serial primary key,
          old_id text,
          name text not null,
          user_id int not null);
     create table if not exists docs (
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          old_map_id text,
          map_id int,
          filename text primary key not null,
          original_filename text,
          name text,
          user_id int not null);
END LOOP;
END
$do$

-------- Set intersystems to users

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     ALTER TABLE users DROP COLUMN IF EXISTS remote_url CASCADE;
     ALTER TABLE users ADD COLUMN IF NOT EXISTS remote_schema text;
     ALTER TABLE users ADD COLUMN IF NOT EXISTS is_intersystem boolean NOT NULL DEFAULT 'f'::boolean;
     UPDATE users u SET remote_schema = (select REGEXP_REPLACE(REGEXP_REPLACE(url, '^(https?://)?(www\.)?', ''), '\.letsa\.net$', '')
          from letsgroups l
          where l.localletscode = u.letscode and l.apimethod = 'elassoap');
     UPDATE users u SET is_intersystem = 't'::boolean from letsgroups l where (l.localletscode = u.letscode and l.apimethod <> 'internal') or u.role = 'guest';
     UPDATE users u SET remote_schema = null where remote_schema like '%.%';
     UPDATE users u SET remote_schema = 'letsdendermonde' where remote_schema = 'dendermonde';
     UPDATE users u SET remote_schema = 'letsdurme' where remote_schema = 'durme';
END LOOP;
END
$do$
;


---- test

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     ALTER TABLE users DROP COLUMN IF EXISTS remote_url CASCADE;
     ALTER TABLE users ADD COLUMN IF NOT EXISTS remote_schema text;
     ALTER TABLE users ADD COLUMN IF NOT EXISTS is_intersystem boolean NOT NULL DEFAULT 'f'::boolean;
     UPDATE users u SET remote_schema = (select url from letsgroups l where l.localletscode = u.letscode and l.apimethod = 'elassoap');
     UPDATE users u SET is_intersystem = 't'::boolean from letsgroups l where l.localletscode = u.letscode and l.apimethod <> 'internal';
     UPDATE users u SET remote_schema = null where remote_schema like '%.%';
     UPDATE users u SET remote_schema = 'letsdendermonde' where remote_schema = 'dendermonde';
     UPDATE users u SET remote_schema = 'letsdurme' where remote_schema = 'durme';
END LOOP;
END
$do$
;

-------------------------------

CREATE TABLE IF NOT EXISTS xdb.test_col (
     code text,
     t_schema text
);

--------------------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     INSERT INTO xdb.test_col(code, t_schema)
          SELECT localletscode, f_schema from letsgroups;
END LOOP;
END
$do$
;

----------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     UPDATE messages m
     SET image_files = '[]'::jsonb where image_files is null;
END LOOP;
END
$do$

-----


DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE messages
        ADD COLUMN IF NOT EXISTS access text
        ;
   ALTER TABLE users
        ADD COLUMN IF NOT EXISTS fullname_access text
        ;
   ALTER TABLE contact
        ADD COLUMN IF NOT EXISTS access text
        ;
   ALTER TABLE news
        ADD COLUMN IF NOT EXISTS access text
        ;
    DROP TABLE IF EXISTS apikeys CASCADE;
END LOOP;

END
$do$

---

DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     UPDATE users SET fullname_access = 'guest'
          WHERE id IN (SELECT eland_id::int
               FROM xdb.aggs
               WHERE agg_schema = f_schema
                    AND agg_type = 'user_fullname_access'
                    AND data->>'fullname_access' = 'interlets');
     UPDATE users SET fullname_access = 'user'
          WHERE id IN (SELECT eland_id::int
               FROM xdb.aggs
               WHERE agg_schema = f_schema
                    AND agg_type = 'user_fullname_access'
                    AND data->>'fullname_access' = 'users');
     UPDATE users SET fullname_access = 'admin'
          WHERE id IN (SELECT eland_id::int
               FROM xdb.aggs
               WHERE agg_schema = f_schema
                    AND agg_type = 'user_fullname_access'
                    AND data->>'fullname_access' = 'admin');

     UPDATE users SET fullname_access = 'admin'
          WHERE fullname_access IS NULL;

END LOOP;

END
$do$

----

DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     UPDATE contact SET access = 'guest'
          WHERE flag_public = 2;
     UPDATE contact SET access = 'user'
          WHERE flag_public = 1;
     UPDATE contact SET access = 'admin'
          WHERE flag_public = 0;

END LOOP;

END
$do$

---

DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     UPDATE messages SET access = 'user' where local = 'true';
     UPDATE messages SET access = 'guest' where local = 'false';
     UPDATE messages SET access = 'user' where local IS NULL;
END LOOP;

END
$do$

---

DO
$do$
DECLARE
  f_schema text;
BEGIN

FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     ALTER TABLE messages DROP COLUMN local;
END LOOP;

END
$do$

----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     INSERT INTO forum_topics(created_at, last_edit_at, access, old_id, user_id, subject)
          SELECT ts, ts, data->>'access', eland_id, CAST(data->>'uid' AS int), data->>'subject'
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'subject' IS NOT NULL
          ORDER BY ts ASC;
END LOOP;
END
$do$
;

-----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     TRUNCATE forum_posts;
END LOOP;
END
$do$
;

---


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     ALTER TABLE forum_posts RENAME COLUMN parent_id TO topic_id;
END LOOP;
END
$do$
;

----

                                             Table "x.forum_posts"
    Column     |            Type             | Collation | Nullable |                  Default
---------------+-----------------------------+-----------+----------+-------------------------------------------
 created_at    | timestamp without time zone |           | not null | timezone('utc'::text, now())
 last_edit_at  | timestamp without time zone |           | not null | timezone('utc'::text, now())
 id            | integer                     |           | not null | nextval('x.forum_posts_id_seq'::regclass)
 topic_id      | integer                     |           |          |
 old_parent_id | text                        |           |          |
 content       | text                        |           | not null |
 edit_count    | integer                     |           | not null | 0
 user_id       | integer                     |           | not null |
Indexes:
    "forum_posts_pkey" PRIMARY KEY, btree (id)

---


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     INSERT INTO forum_topics(created_at, last_edit_at, access, old_id, user_id, subject)
          SELECT ts, ts, data->>'access', eland_id, CAST(data->>'uid' AS int), data->>'subject'
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'subject' IS NOT NULL
          ORDER BY ts ASC;

     INSERT INTO forum_posts(created_at, last_edit_at, old_parent_id, user_id, content, edit_count)
          SELECT ts, ts, eland_id, CAST(data->>'uid' AS int), data->>'content', agg_version - 1
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'content' IS NOT NULL
               AND data->>'subject' IS NOT NULL
               AND data->>'parent_id' IS NULL
          ORDER BY ts ASC;

     INSERT INTO forum_posts(created_at, last_edit_at, old_parent_id, user_id, content, edit_count)
          SELECT ts, ts, data->>'parent_id', CAST(data->>'uid' AS int), data->>'content', agg_version - 1
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'content' IS NOT NULL
               AND data->>'subject' IS NULL
          ORDER BY ts ASC;
END LOOP;
END
$do$
;



---- Delete forum data --------------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     TRUNCATE TABLE forum_topics;
     TRUNCATE TABLE forum_posts;

END LOOP;
END
$do$
;

---- Insert forum data

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     INSERT INTO forum_topics(created_at, last_edit_at, access, old_id, user_id, subject)
          SELECT ts, ts, data->>'access', eland_id, CAST(data->>'uid' AS int), data->>'subject'
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'subject' IS NOT NULL
          ORDER BY ts ASC;

     INSERT INTO forum_posts(created_at, last_edit_at, old_id, old_parent_id, user_id, content, edit_count)
          SELECT ts, ts, eland_id, eland_id, CAST(data->>'uid' AS int), data->>'content', agg_version - 1
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'content' IS NOT NULL
               AND data->>'subject' IS NOT NULL
               AND data->>'parent_id' IS NULL
          ORDER BY ts ASC;

     INSERT INTO forum_posts(created_at, last_edit_at, old_id, old_parent_id, user_id, content, edit_count)
          SELECT ts, ts, eland_id, data->>'parent_id', CAST(data->>'uid' AS int), data->>'content', agg_version - 1
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'forum'
               AND data->>'content' IS NOT NULL
               AND data->>'subject' IS NULL
               AND data->>'uid' IS NOT NULL
          ORDER BY ts ASC;
END LOOP;
END
$do$
;

--------------- Update forum data


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     UPDATE forum_topics SET access = 'guest' WHERE access = 'interlets';
     UPDATE forum_topics SET access = 'user' WHERE access = 'users';
     UPDATE forum_posts p SET topic_id = (select id from forum_topics t where t.old_id = p.old_parent_id);

END LOOP;
END
$do$
;

---- Update last edit

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     UPDATE forum_posts p SET last_edit_at =
          (SELECT max(e.ts) FROM xdb.events e WHERE e.eland_id = p.old_id);
     UPDATE forum_topics t SET last_edit_at =
          (SELECT max(e.ts) FROM xdb.events e WHERE e.eland_id = t.old_id);
END LOOP;
END
$do$
;


---------



DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     ALTER TABLE forum_topics DROP COLUMN old_id;
     ALTER TABLE forum_posts DROP COLUMN old_id;
     ALTER TABLE forum_posts DROP COLUMN old_parent_id;
END LOOP;
END
$do$
;

----- DROP DOCS and DOC_MAPS

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     DROP TABLE doc_maps CASCADE;
     DROP TABLE docs CASCADE;
END LOOP;
END
$do$
;

----- CREATE doc_maps and docs

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     create table if not exists doc_maps (
          id serial primary key not null,
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          old_id text,
          name text not null,
          user_id int not null);
     create table if not exists docs (
          id serial primary key not null,
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          old_map_id text,
          map_id int,
          filename text not null,
          original_filename text,
          name text,
          user_id int not null,
          access text not null default 'admin'::text);
END LOOP;
END
$do$

----- INSERT DOCS and DOC_MAPS


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     INSERT INTO doc_maps(created_at, last_edit_at, old_id, user_id, name)
          SELECT ts, ts, eland_id, user_id, data->>'map_name'
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'doc'
               AND data->>'map_name' IS NOT NULL
          ORDER BY ts ASC;

     INSERT INTO docs(created_at, last_edit_at, old_map_id, user_id, filename, original_filename, name, access)
          SELECT ts, ts, data->>'map_id', CAST(data->>'user_id' AS int), data->>'filename', data->>'org_filename', data->>'name', data->>'access'
          FROM xdb.aggs
          WHERE agg_schema = f_schema
               AND agg_type = 'doc'
               AND data->>'map_name' IS NULL
          ORDER BY ts ASC;
END LOOP;
END
$do$
;

---- UPDATE docs

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;

     UPDATE docs SET access = 'guest' WHERE access = 'interlets';
     UPDATE docs SET access = 'user' WHERE access = 'users';
     UPDATE docs SET access = 'admin' WHERE access IS NULL;
     UPDATE docs SET name = NULL WHERE name = '';
     UPDATE docs d SET map_id = (select m.id from doc_maps m where m.old_id = d.old_map_id);
     UPDATE doc_maps m SET user_id = (select d.user_id from docs d where m.old_id = d.old_map_id order by d.created_at asc limit 1) where m.user_id IS NULL;

END LOOP;
END
$do$
;

----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
     EXECUTE 'SET LOCAL search_path = ' || f_schema;
     UPDATE users SET fullname_access = 'admin' WHERE fullname_access IS NULL;
END LOOP;
END
$do$
;

---


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   CREATE TABLE IF NOT EXISTS static_content (
        id text not null,
        lang text not null,
        data jsonb not null default '{}'::jsonb,
        created_at timestamp without time zone default timezone('utc'::text, now()),
        last_edit_at timestamp without time zone default timezone('utc'::text, now()),
        PRIMARY KEY(id, lang)
   );
     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON static_content
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();
END LOOP;
END
$do$
;

---

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON config
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();
END LOOP;
END
$do$
;

----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     CREATE OR REPLACE FUNCTION trigger_set_last_edit_at()
     RETURNS TRIGGER AS $$
     BEGIN
     NEW.last_edit_at := timezone('utc'::text, NOW());
     NEW.edit_count := OLD.edit_count + 1;
     RETURN NEW;
     END;
     $$ LANGUAGE plpgsql;
END LOOP;
END
$do$
;

----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
     CREATE OR REPLACE FUNCTION trigger_set_last_login_at()
     RETURNS TRIGGER AS $$
     BEGIN
     NEW.last_login_at := timezone('utc'::text, NOW());
     NEW.login_count := OLD.login_count + 1;
     RETURN NEW;
     END;
     $$ LANGUAGE plpgsql;
END LOOP;
END
$do$
;


----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON docs
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON doc_maps
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON forum_topics
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON forum_posts
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();
END LOOP;
END
$do$
;

-----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     DROP TABLE IF EXISTS login;
     DROP TABLE IF EXISTS logout;

END LOOP;
END
$do$
;

-----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     ALTER TABLE config ADD COLUMN IF NOT EXISTS user_id int;

END LOOP;
END
$do$
;

-----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE docs ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE doc_maps ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE forum_topics ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE forum_posts ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE config ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE static_content ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE users ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE users ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE users ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE news ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE news ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE news ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE messages ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE messages ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE messages ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     UPDATE users SET adate = cdate where adate is null and status in (1, 2);
     UPDATE users SET adate = mdate where adate is null and status in (1, 2);

     UPDATE users SET cdate = adate where cdate is null and adate is not null;
     UPDATE users SET mdate = cdate where mdate is null and cdate is not null;

     UPDATE messages SET mdate = cdate where mdate is null and cdate is not null;
     UPDATE news SET cdate = itemdate where cdate is null and itemdate is not null;

     UPDATE users SET created_at = cdate;
     UPDATE users SET last_edit_at = mdate;

     UPDATE news SET created_at = cdate;
     UPDATE news SET last_edit_at = cdate;

     UPDATE messages SET created_at = cdate;
     UPDATE messages SET last_edit_at = mdate;

     UPDATE transactions SET created_at = cdate;
     UPDATE transactions SET last_edit_at = cdate;

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON users;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON users
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON news;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON news
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON messages;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON messages
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON transactions;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON transactions
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

END LOOP;
END
$do$
;

---------------------- MOLLIE -------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     ALTER TABLE users
          ADD COLUMN has_open_mollie_payment bool NOT NULL DEFAULT 'f'::bool;

     CREATE TABLE IF NOT EXISTS mollie_payments(
          id serial primary key not null,
          token text,
          user_id int not null,
          mollie_payment_id text,
          request_id int not null,
          emails_sent jsonb not null default '[]'::jsonb,
          amount numeric(5, 2) not null,
          currency text not null,
          mollie_status text,
          is_canceled bool not null default 'f'::bool,
          canceled_at timestamp without time zone,
          canceled_by int,
          is_payed bool not null default 'f'::bool,
          payed_at timestamp without time zone,
          created_by int not null,
          created_at timestamp without time zone not null default timezone('utc'::text, now()),
          last_edit_at timestamp without time zone not null default timezone('utc'::text, now()),
          edit_count int not null default 0
     );

     CREATE TABLE IF NOT EXISTS mollie_payment_requests(
        id serial primary key not null,
        description text not null,
        created_by int not null,
        created_at timestamp without time zone not null default timezone('utc'::text, now())
     );

     CREATE TABLE IF NOT EXISTS emails(
          id serial primary key not null,
          subject text not null,
          content text not null,
          sent_to jsonb not null,
          route text not null,
          created_by int not null,
          created_at timestamp without time zone not null default timezone('utc'::text, now())
     );

END LOOP;
END
$do$
;

------------------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     CREATE OR REPLACE FUNCTION trigger_set_payed_at()
     RETURNS TRIGGER AS $$
     BEGIN
     NEW.payed_at := timezone('utc'::text, NOW());
     RETURN NEW;
     END;
     $$ LANGUAGE plpgsql;

     CREATE OR REPLACE FUNCTION trigger_set_canceled_at()
     RETURNS TRIGGER AS $$
     BEGIN
     NEW.canceled_at := timezone('utc'::text, NOW());
     NEW.is_canceled := 't'::bool;
     RETURN NEW;
     END;
     $$ LANGUAGE plpgsql;

END LOOP;
END
$do$
;

----


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     DROP TRIGGER IF EXISTS set_payed_at
     ON mollie_payments;

     CREATE TRIGGER set_payed_at
     BEFORE UPDATE OF is_payed ON mollie_payments
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_payed_at();

     DROP TRIGGER IF EXISTS set_canceled_at
     ON mollie_payments;

     CREATE TRIGGER set_canceled_at
     BEFORE UPDATE OF canceled_by ON mollie_payments
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_canceled_at();

END LOOP;
END
$do$
;


----------------------------------------------------------


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;
   ALTER TABLE docs ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE doc_maps ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE forum_topics ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE forum_posts ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE config ADD COLUMN IF NOT EXISTS edit_count int not null default 0;
   ALTER TABLE static_content ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE users ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE users ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE users ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE news ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE news ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE news ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE messages ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE messages ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE messages ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS created_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS last_edit_at timestamp without time zone not null default timezone('utc'::text, now());
     ALTER TABLE transactions ADD COLUMN IF NOT EXISTS edit_count int not null default 0;

     UPDATE users SET adate = cdate where adate is null and status in (1, 2);
     UPDATE users SET adate = mdate where adate is null and status in (1, 2);

     UPDATE users SET cdate = adate where cdate is null and adate is not null;
     UPDATE users SET mdate = cdate where mdate is null and cdate is not null;

     UPDATE messages SET mdate = cdate where mdate is null and cdate is not null;
     UPDATE news SET cdate = itemdate where cdate is null and itemdate is not null;

     UPDATE users SET created_at = cdate;
     UPDATE users SET last_edit_at = mdate;

     UPDATE news SET created_at = cdate;
     UPDATE news SET last_edit_at = cdate;

     UPDATE messages SET created_at = cdate;
     UPDATE messages SET last_edit_at = mdate;

     UPDATE transactions SET created_at = cdate;
     UPDATE transactions SET last_edit_at = cdate;

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON users;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON users
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON news;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON news
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON messages;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON messages
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

     DROP TRIGGER IF EXISTS set_last_edit_at
     ON transactions;

     CREATE TRIGGER set_last_edit_at
     BEFORE UPDATE ON transactions
     FOR EACH ROW
     EXECUTE PROCEDURE trigger_set_last_edit_at();

END LOOP;
END
$do$
;

---

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     ALTER TABLE static_content ADD COLUMN IF NOT EXISTS created_by int NOT NULL;
     ALTER TABLE static_content ADD COLUMN IF NOT EXISTS last_edit_by int NOT NULL;
     ALTER TABLE static_content_images ADD COLUMN IF NOT EXISTS created_by int NOT NULL;
     ALTER TABLE users ALTER COLUMN fullname_access SET DEFAULT 'admin'::text;
     UPDATE users SET fullname_access = 'admin' WHERE fullname_access is null;
     ALTER TABLE users ALTER COLUMN fullname_access SET NOT NULL;

END LOOP;
END
$do$
;

----

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     ALTER TABLE config ADD COLUMN IF NOT EXISTS created_by int NOT NULL;


END LOOP;
END
$do$
;

------------- CONFIG -------------------------

DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     INSERT INTO config (id) SELECT 'system'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'system');

     INSERT INTO config (id) SELECT 'mail'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'mail');

     INSERT INTO config (id) SELECT 'periodic_mail'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'periodic_mail');

     INSERT INTO config (id) SELECT 'transactions'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'transactions');

     INSERT INTO config (id) SELECT 'messages'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'messages');

     INSERT INTO config (id) SELECT 'users'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'users');

     INSERT INTO config (id) SELECT 'register'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'register');

     INSERT INTO config (id) SELECT 'contact'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'contact');

     INSERT INTO config (id) SELECT 'support'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'support');

     INSERT INTO config (id) SELECT 'news'
          WHERE NOT EXISTS (SELECT 't'::boolean from config where id = 'news');

     UPDATE config SET data = jsonb_set(data, '{sort}', '{}'::jsonb)
          where id = 'news';



     UPDATE config SET data = jsonb_set(data, '{currency}', '{}'::jsonb)
          where id = 'transactions';



     UPDATE config SET data = jsonb_set(data, '{cleanup}', '{}'::jsonb)
          where id = 'messages';

     UPDATE config SET data = jsonb_set(data, '{cleanup, enabled}', 'true'::jsonb)
          where id = 'messages';

     UPDATE config SET data = jsonb_set(data, '{cleanup, after_days}', (select data->>'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'msgexpcleanupdays')::jsonb)
          where id = 'messages';

     UPDATE config SET data = jsonb_set(data, '{sort, asc}', 'true'::jsonb)
          where id = 'news';

     UPDATE config SET data = jsonb_set(data, '{modules,contact,enabled}', 'false'::jsonb)
          where id = 'news' and exists (select 1
               from xdb.aggs
               where agg_type = 'setting'
                    and agg_schema = f_schema
                    and eland_id = 'news_order_asc'
                    and (data->>'value' = '0'
                         or data->>'value' = ''
                         or data->>'value' IS NULL));

     UPDATE config SET data = jsonb_set(data, '{blocks}', coalesce((select jsonb_agg(to_jsonb(t.unnest))
          from (select unnest(string_to_array(ltrim(a.data->>'value', '+'), ','))
               from xdb.aggs a
               where agg_type = 'setting'
                    and eland_id = 'periodic_mail_block_ary'
                    and agg_schema = f_schema) t), '["messages.recent"]'::jsonb))
          WHERE id = 'periodic_mail';

     UPDATE config SET data = jsonb_set(data, '{days}', (select data->>'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'saldofreqdays')::jsonb)
          where id = 'periodic_mail';

     UPDATE config SET data = jsonb_set(data, '{modules}',
               '{"messages":{"enabled":true, "access": "guest"},"users":{"enabled":true, "access": "guest"}, "transactions":{"enabled": true, "access":"guest"}, "news":{"enabled":true, "access": "guest"}, "docs":{"enabled":true, "access":"guest"}, "forum":{"enabled":true, "access":"guest"}, "support":{"enabled": true, "access": "user"}, "home": {"enabled":true}, "login": {"enabled":true}, "contact":{"enabled":true}, "register":{"enabled":true}}'::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{modules,contact,enabled}', 'false'::jsonb)
          where id = 'system' and exists (select 1
               from xdb.aggs
               where agg_type = 'setting'
                    and agg_schema = f_schema
                    and eland_id = 'contact_form_en'
                    and (data->>'value' = '0'
                         or data->>'value' = ''));

     UPDATE config SET data = jsonb_set(data, '{modules,register,enabled}', 'false'::jsonb)
          where id = 'system' and exists (select 1
               from xdb.aggs
               where agg_type = 'setting'
                    and agg_schema = f_schema
                    and eland_id = 'registration_en'
                    and (data->>'value' = '0'
                         or data->>'value' = ''));

     UPDATE config SET data = jsonb_set(data, '{modules,forum,enabled}', 'false'::jsonb)
          where id = 'system' and exists (select 1
               from xdb.aggs
               where agg_type = 'setting'
                    and agg_schema = f_schema
                    and eland_id = 'forum_en'
                    and (data->>'value' = '0'
                         or data->>'value' = ''));

     UPDATE config SET data = jsonb_set(data, '{website_url}', coalesce((select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'homepage_url'
               and data->>'value' is not null
               and data->>'value' <> '')::jsonb, 'null'::jsonb))
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{default_landing_page}', coalesce((select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'default_landing_page'
               and data->>'value' is not null
               and data->>'value' <> '')::jsonb, '"messages"'::jsonb))
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{currency, name}', (select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'currency')::jsonb)
          where id = 'transactions';

     UPDATE config SET data = jsonb_set(data, '{currency, per_hour_ratio}', (select data->>'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'currencyratio')::jsonb)
          where id = 'transactions';

     UPDATE config SET data = jsonb_set(data, '{currency, timebased_en}', (select (case
          when data->>'value' = '0' then 'f'::boolean
          when data->>'value' = '' then 'f'::boolean
          when data->>'value' = 'false' then 'f'::boolean
          else 't'::boolean
          end)::text
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'template_lets')::jsonb)
          where id = 'transactions';

     UPDATE config SET data = jsonb_set(data, '{name}', (select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'systemname')::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{date_format}', (select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'date_format')::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{logo}', (select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'logo')::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{maintenance_en}', (select (case
          when data->>'value' = '0' then 'f'::boolean
          when data->>'value' = '' then 'f'::boolean
          when data->>'value' = 'false' then 'f'::boolean
          else 't'::boolean
          end)::text
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'maintenance')::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{intersystem_en}', (select (case
          when data->>'value' = '0' then 'f'::boolean
          when data->>'value' = '' then 'f'::boolean
          when data->>'value' = 'false' then 'f'::boolean
          else 't'::boolean
          end)::text
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'interlets_en')::jsonb)
          where id = 'system';

     UPDATE config SET data = jsonb_set(data, '{tag}', (select data->'value'
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'systemtag')::jsonb)
          where id = 'mail';

     UPDATE config SET data = jsonb_set(data, '{enabled}', (select (case
          when data->>'value' = '0' then 'f'::boolean
          when data->>'value' = '' then 'f'::boolean
          when data->>'value' = 'false' then 'f'::boolean
          else 't'::boolean
          end)::text
          from xdb.aggs
          where agg_type = 'setting'
               and agg_schema = f_schema
               and eland_id = 'mailenabled')::jsonb)
          where id = 'mail';

     UPDATE config SET data = jsonb_set(data, '{mail,admin_addresses}', (select jsonb_agg(to_jsonb(t.unnest))
          from (select unnest(string_to_array(data->>'value', ','))
               from xdb.aggs
               where agg_type = 'setting'
                    and eland_id = 'admin'
                    and agg_schema = f_schema) t))
          WHERE id = 'system';

     UPDATE config SET data = jsonb_set(data, '{id}', ('"'|| public.uuid_generate_v4() ||'"')::jsonb)
          WHERE id = 'system';

END LOOP;
END
$do$
;

----------------- drop remoteapikey --------------------------------------


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <>  'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

   ALTER TABLE letsgroups
        DROP COLUMN IF EXISTS remoteapikey,
        DROP COLUMN IF EXISTS presharedkey,
        DROP COLUMN IF EXISTS shortname,
        DROP COLUMN IF EXISTS prefix,
        DROP COLUMN IF EXISTS elassoapurl,
        DROP COLUMN IF EXISTS pubkey
        ;
END LOOP;

END
$do$

--------- Drop unused sequences --------------------


DO
$do$
DECLARE
  f_schema text;
BEGIN
FOR f_schema IN
    SELECT quote_ident(nspname)
    FROM   pg_namespace n
    WHERE  nspname !~~ 'pg_%'
    AND    nspname <> 'information_schema'
    AND    nspname <> 'xdb'
    AND    nspname <> 'c'
    AND    nspname <> 'e'
    AND    nspname <> 'migration'
    AND    nspname <> 'public'
LOOP
   EXECUTE 'SET LOCAL search_path = ' || f_schema;

     DROP SEQUENCE IF EXISTS apikeys_id_seq;
     DROP SEQUENCE IF EXISTS msgpictures_id_seq;
     DROP SEQUENCE IF EXISTS openid_id_seq;
     DROP SEQUENCE IF EXISTS ostatus_queue_id_seq;
     DROP SEQUENCE IF EXISTS regions_id_seq;

END LOOP;
END
$do$
;
